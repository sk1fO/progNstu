package main

// структура данных полного бинарного дерева
type CBTree struct {
	data []interface{} // срез для хранения элементов дерева
}

// создает и возвращает указатель на новое пустое полное бинарное дерево
func NewCBTree() *CBTree {
	return &CBTree{data: make([]interface{}, 0)} // Инициализируем пустой массив для хранения элементов
}

// добавляет элемент в полное бинарное дерево
func (t *CBTree) Add(value interface{}) {
	t.data = append(t.data, value) // добавляем элемент в конец массива
}

// проверяет, содержит ли дерево заданное значение.
func (t *CBTree) Find(value interface{}) bool {
	for _, v := range t.data { // Проходим по всем элементам массива
		if v == value {
			return true // Возвращаем true, если значение найдено
		}
	}
	return false // Возвращаем false, если значение не найдено
}

// проверяет, является ли дерево полным бинарным деревом.
func (t *CBTree) IsComplete() bool {
	n := len(t.data)         // Получаем количество элементов в массиве
	for i := 0; i < n; i++ { // Проходим по всем элементам массива
		left := 2*i + 1                      // Индекс левого потомка
		right := 2*i + 2                     // Индекс правого потомка
		if left < n && t.data[left] == nil { // Проверяем, существует ли левый потомок
			return false // Если левый потомок отсутствует, дерево не является полным
		}
		if right < n && t.data[right] == nil { // Проверяем, существует ли правый потомок
			return false // Если правый потомок отсутствует, дерево не является полным
		}
	}
	return true // Если все проверки пройдены, дерево является полным
}

// возвращает копию всех элементов дерева.
func (t *CBTree) Read() []interface{} {
	return t.data // Возвращаем массив с элементами дерева
}
